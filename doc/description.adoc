////
Copyright 2023 Tobias Loew
Distributed under the Boost Software License, Version 1.0.
http://www.boost.org/LICENSE_1_0.txt
////

[#description]
# Description
:toc:
:toc-title:
:idprefix:

The header `<boost/flags.hpp>` provides type-safe bitwise operations for scoped and unscoped flag-like enumerations in a non-intrusive way.


Why using Boost.Flags?

It is quite common to use the bits of an integer type for representing different options. 
One possible way is using a plain unsigned integer and defining the different options as macros. As an example here some code from `<winuser.h>` defining the Windows listbox control styles
```
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
...
#define LBS_NOSEL             0x4000L
```
This approach has the advantage that all the bitwise operators are available. But when dealing with multiple sets of options, there is no way for the compiler to check that only 'compatible' options are used which each other. E.g. also defined in `<WinUser.h>` we find the styles for button controls
```
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
```
So, an statement like 
```
    if (listbox_style & BS_NOTIFY) { ...
``` 
will compile, but won't execute as aspected since the programmer accidentially wrote `BS_NOTIFY` instead of `LBS_NOTIFY`.

Additionally since the type used to store those flags is an integer, there is no way to prohibit accedintially passing a variable of flags to a function, where flags from a different set were expected.

A better approach is using unscoped enumeration instead of plain integers: 
```
enum flags_a {
	flags_a_opt_1 = 0x1,
	flags_a_opt_2 = 0x2,
	flags_a_opt_4 = 0x4,
};

enum flags_b {
	flags_b_opt_1 = 0x1,
	flags_b_opt_2 = 0x2,
	flags_b_opt_4 = 0x4,
};
```
Now there will be a compiler-error, when we try to pass members or variables of type `flags_a` to a function expecting `flags_b`.

But still there is no way to prohibit logical errors like
```
	flags_a a = get_flags_a();
    if (a & flags_b_opt_1) { 
``` 
since the compiler implicitly promotes unscoped enums to integers.

And here we come to the next problem with unscoped enums: the result type of binary logical operations and the unary negation is an integer type. So, when assigning it to a enum flags variable we need a `static_cast`, which is again a source for logical errors. Consequently, the binary assignment operators are not available at all.

Using scoped enumerations makes it even worse since then also binary logical operations are no longer available.


When dealing with flags it is also common to use bit-masks for filtering. Here we have to differentiate between positive masks, which are bitwise or of flags, and their complement negative masks.
Positive masks are used for filtering out certain flags or checking for their existance
```
	// for simplicity we use plain integer flags
#define OPT_1 0x1	
#define OPT_2 0x2	
#define OPT_3 0x4	
	unsigned mask_1_2 = OPT_1 | OPT_2;
	unsigned options = get_options();
    if (options & mask_1_2) {  // OPT_1 or OPT_2 is set
```
while negative masks are used for disabling flags
```
	unsigned mask_3 = ~(OPT_3);
	unsigned options = get_options();
	a &= mask_3;		// unset OPT_3 
```


The use of the bits of an underlying type for

For enabled enumeration is enabled for type-safe bitwise operations, then all the bitwise operators `&, &=, |, |=, ^, ^=` and `~`
are type preserving.

Flag-like enumerations are usually used when there is a set of binary options `a,b,c,...` and then defined e.g. like
```
enum flags {
  flag_a = 0x1,
  flag_b = 0x2,
  flag_c = 0x4,
  // ...
};
```
For unscoped enums


The bitwise-operations &, &=, |, |=, ^ and ^= when applied to an enabled enumeration all return the type of the enumeration again.
The negation-operation operator~(E e) returns as type bitmask to account for the fact that the negation of a set of flags is in general 
not a set of flags but has also all _unused_ bits sets.
From a mathematical point of view speaking are the operations ~, &, | are also a boolean algebra on the the set {E, bitmask}). The library takes this into account and e.g. only prevents modifying operatiors &=, |= and ^= for incompatible types. E.g. operator |=(E& e1, bitmaks e2) is not allowed as it would turn e1 from a combinations of flags into a bitmask.




`boost::throw_exception(x);` is a replacement for `throw x;` that both
degrades gracefully when exception handling support is not available, and
integrates the thrown exception into facilities provided by
link:../../../exception/index.html[Boost.Exception], such as automatically
providing a base class of type `boost::exception` and support for
`boost::exception_ptr`.

When exception handling is not available, the function is only declared, but
not defined. This allows users to provide their own definition.

An overload for `boost::throw_exception` that takes a
link:../../../assert/doc/html/assert.html#source_location_support[`boost::source_location`]
is provided. It records the supplied source location into the `boost::exception`
base class, from where it can later be retrieved when the exception is caught.
link:../../../exception/doc/diagnostic_information.html[`boost::diagnostic_information`]
automatically displays the stored source location.

The macro `BOOST_THROW_EXCEPTION(x)` expands to
`::boost::throw_exception(x, BOOST_CURRENT_LOCATION)`, passing the current source
location.

When integration with Boost.Exception and `boost::exception_ptr` is not needed,
the function `boost::throw_with_location` can be used instead. It also throws
a user-provided exception, associating it with a supplied or inferred source
location, but does not supply the `boost::exception` base class and does not
enable `boost::exception_ptr` support.

The source location of the exception thrown by `boost::throw_with_location`
can be retrieved, after `catch(std::exception const & x)`, by using
`boost::get_throw_location(x)`.

`boost::get_throw_location` also works for exceptions thrown by the two argument
overload of `boost::throw_exception`, or by `BOOST_THROW_EXCEPTION`; in this case
it returns the source location stored in the `boost::exception` base class.


////
Copyright 2002, 2007, 2014, 2017 Peter Dimov
Copyright 2011 Beman Dawes
Copyright 2015 Ion Gazta√±aga

Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////

[#assertion_macros]
# Assertion Macros, <boost/assert.hpp>
:toc:
:toc-title:
:idprefix:

## BOOST_ASSERT

The header `<boost/assert.hpp>` defines the macro `BOOST_ASSERT`,
which is similar to the standard `assert` macro defined in `<cassert>`.
The macro is intended to be used in both Boost libraries and user
code.

* By default, `BOOST_ASSERT(expr)` expands to `assert(expr)`.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_ASSERT(expr)` expands to `((void)0)`, regardless of whether
  the macro `NDEBUG` is defined. This allows users to selectively disable `BOOST_ASSERT` without 
  affecting the definition of the standard `assert`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT(expr)` expands to
+
```
(BOOST_LIKELY(!!(expr))? ((void)0): ::boost::assertion_failed(#expr,
    BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
```
+
That is, it evaluates `expr` and if it's false, calls
`::boost::assertion_failed(#expr, <<current_function.adoc#boost_current_function,BOOST_CURRENT_FUNCTION>>, \\__FILE__, \\__LINE__)`.
This is true regardless of whether `NDEBUG` is defined.
+
`boost::assertion_failed` is declared in `<boost/assert.hpp>` as
+
```
namespace boost
{
    void assertion_failed(char const * expr, char const * function,
        char const * file, long line);
}
```
+
but it is never defined. The user is expected to supply an appropriate definition.

* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT(expr)` expands to `((void)0)` when `NDEBUG` is
defined. Otherwise the behavior is as if `BOOST_ENABLE_ASSERT_HANDLER` has been defined.

As is the case with `<cassert>`, `<boost/assert.hpp>`
can be included multiple times in a single translation unit. `BOOST_ASSERT`
will be redefined each time as specified above.

## BOOST_ASSERT_MSG

The macro `BOOST_ASSERT_MSG` is similar to `BOOST_ASSERT`, but it takes an additional argument,
a character literal, supplying an error message.

* By default, `BOOST_ASSERT_MSG(expr,msg)` expands to `assert\((expr)&&(msg))`.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr,msg)` expands to `((void)0)`, regardless of whether
the macro `NDEBUG` is defined.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr,msg)` expands to
+
```
(BOOST_LIKELY(!!(expr))? ((void)0): ::boost::assertion_failed_msg(#expr,
    msg, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
```
+
This is true regardless of whether `NDEBUG` is defined.
+
`boost::assertion_failed_msg` is declared in `<boost/assert.hpp>` as
+
```
namespace boost
{
    void assertion_failed_msg(char const * expr, char const * msg,
        char const * function, char const * file, long line);
}
```
+
but it is never defined. The user is expected to supply an appropriate definition.

* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr)` expands to `((void)0)` when `NDEBUG` is
defined. Otherwise the behavior is as if `BOOST_ENABLE_ASSERT_HANDLER` has been defined.

As is the case with `<cassert>`, `<boost/assert.hpp>`
can be included multiple times in a single translation unit. `BOOST_ASSERT_MSG`
will be redefined each time as specified above.

## BOOST_VERIFY

The macro `BOOST_VERIFY` has the same behavior as `BOOST_ASSERT`, except that 
the expression that is passed to `BOOST_VERIFY` is always 
evaluated. This is useful when the asserted expression has desirable side 
effects; it can also help suppress warnings about unused variables when the 
only use of the variable is inside an assertion.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY(expr)` expands to `\((void)(expr))`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY(expr)` expands to `BOOST_ASSERT(expr)`.

* Otherwise, `BOOST_VERIFY(expr)` expands to `\((void)(expr))` when `NDEBUG` is
  defined, to `BOOST_ASSERT(expr)` when it's not.

## BOOST_VERIFY_MSG

The macro `BOOST_VERIFY_MSG` is similar to `BOOST_VERIFY`, with an additional parameter, an error message.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY_MSG(expr,msg)` expands to `\((void)(expr))`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY_MSG(expr,msg)` expands to `BOOST_ASSERT_MSG(expr,msg)`.

* Otherwise, `BOOST_VERIFY_MSG(expr,msg)` expands to `\((void)(expr))` when `NDEBUG` is
  defined, to `BOOST_ASSERT_MSG(expr,msg)` when it's not.

## BOOST_ASSERT_IS_VOID

The macro `BOOST_ASSERT_IS_VOID` is defined when `BOOST_ASSERT` and `BOOST_ASSERT_MSG` are expanded to `((void)0)`.
Its purpose is to avoid compiling and potentially running code that is only intended to prepare data to be used in the assertion.

```
void MyContainer::erase(iterator i)
{
// Some sanity checks, data must be ordered
#ifndef BOOST_ASSERT_IS_VOID

    if(i != c.begin()) {
        iterator prev = i;
        --prev;
        BOOST_ASSERT(*prev < *i);
    }
    else if(i != c.end()) {
        iterator next = i;
        ++next;
        BOOST_ASSERT(*i < *next);
    }

#endif

    this->erase_impl(i);
}
```      

* By default, `BOOST_ASSERT_IS_VOID` is defined if `NDEBUG` is defined.
* If the macro `BOOST_DISABLE_ASSERTS` is defined, `BOOST_ASSERT_IS_VOID` is always defined.
* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined, `BOOST_ASSERT_IS_VOID` is never defined.
* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined, then `BOOST_ASSERT_IS_VOID` is defined when `NDEBUG` is defined.
