////
Copyright 2023 Tobias Loew
Distributed under the Boost Software License, Version 1.0.
http://www.boost.org/LICENSE_1_0.txt
////

[#description]
# Description
:toc:
:toc-title:
:idprefix:

The header `<boost/flags.hpp>` provides type-safe bitwise operations on scoped and unscoped flag-like enumerations
in a non-intrusive way.

When an enumeration is enabled for type-safe bitwise operations, then all the bitwise operators `&, &=, |, |=, ^, ^=` and `~`
are type preserving.

Flag-like enumerations are usually used when there is a set of binary options `a,b,c,...` and then defined e.g. like
```
enum flags {
  flag_a = 0x1,
  flag_b = 0x2,
  flag_c = 0x4,
  // ...
};
```
For unscoped enums


The bitwise-operations &, &=, |, |=, ^ and ^= when applied to an enabled enumeration all return the type of the enumeration again.
The negation-operation operator~(E e) returns as type bitmask to account for the fact that the negation of a set of flags is in general 
not a set of flags but has also all _unused_ bits sets.
From a mathematical point of view speaking are the operations ~, &, | are also a boolean algebra on the the set {E, bitmask}). The library takes this into account and e.g. only prevents modifying operatiors &=, |= and ^= for incompatible types. E.g. operator |=(E& e1, bitmaks e2) is not allowed as it would turn e1 from a combinations of flags into a bitmask.

`boost::throw_exception(x);` is a replacement for `throw x;` that both
degrades gracefully when exception handling support is not available, and
integrates the thrown exception into facilities provided by
link:../../../exception/index.html[Boost.Exception], such as automatically
providing a base class of type `boost::exception` and support for
`boost::exception_ptr`.

When exception handling is not available, the function is only declared, but
not defined. This allows users to provide their own definition.

An overload for `boost::throw_exception` that takes a
link:../../../assert/doc/html/assert.html#source_location_support[`boost::source_location`]
is provided. It records the supplied source location into the `boost::exception`
base class, from where it can later be retrieved when the exception is caught.
link:../../../exception/doc/diagnostic_information.html[`boost::diagnostic_information`]
automatically displays the stored source location.

The macro `BOOST_THROW_EXCEPTION(x)` expands to
`::boost::throw_exception(x, BOOST_CURRENT_LOCATION)`, passing the current source
location.

When integration with Boost.Exception and `boost::exception_ptr` is not needed,
the function `boost::throw_with_location` can be used instead. It also throws
a user-provided exception, associating it with a supplied or inferred source
location, but does not supply the `boost::exception` base class and does not
enable `boost::exception_ptr` support.

The source location of the exception thrown by `boost::throw_with_location`
can be retrieved, after `catch(std::exception const & x)`, by using
`boost::get_throw_location(x)`.

`boost::get_throw_location` also works for exceptions thrown by the two argument
overload of `boost::throw_exception`, or by `BOOST_THROW_EXCEPTION`; in this case
it returns the source location stored in the `boost::exception` base class.


////
Copyright 2002, 2007, 2014, 2017 Peter Dimov
Copyright 2011 Beman Dawes
Copyright 2015 Ion Gazta√±aga

Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////

[#assertion_macros]
# Assertion Macros, <boost/assert.hpp>
:toc:
:toc-title:
:idprefix:

## BOOST_ASSERT

The header `<boost/assert.hpp>` defines the macro `BOOST_ASSERT`,
which is similar to the standard `assert` macro defined in `<cassert>`.
The macro is intended to be used in both Boost libraries and user
code.

* By default, `BOOST_ASSERT(expr)` expands to `assert(expr)`.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_ASSERT(expr)` expands to `((void)0)`, regardless of whether
  the macro `NDEBUG` is defined. This allows users to selectively disable `BOOST_ASSERT` without 
  affecting the definition of the standard `assert`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT(expr)` expands to
+
```
(BOOST_LIKELY(!!(expr))? ((void)0): ::boost::assertion_failed(#expr,
    BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
```
+
That is, it evaluates `expr` and if it's false, calls
`::boost::assertion_failed(#expr, <<current_function.adoc#boost_current_function,BOOST_CURRENT_FUNCTION>>, \\__FILE__, \\__LINE__)`.
This is true regardless of whether `NDEBUG` is defined.
+
`boost::assertion_failed` is declared in `<boost/assert.hpp>` as
+
```
namespace boost
{
    void assertion_failed(char const * expr, char const * function,
        char const * file, long line);
}
```
+
but it is never defined. The user is expected to supply an appropriate definition.

* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT(expr)` expands to `((void)0)` when `NDEBUG` is
defined. Otherwise the behavior is as if `BOOST_ENABLE_ASSERT_HANDLER` has been defined.

As is the case with `<cassert>`, `<boost/assert.hpp>`
can be included multiple times in a single translation unit. `BOOST_ASSERT`
will be redefined each time as specified above.

## BOOST_ASSERT_MSG

The macro `BOOST_ASSERT_MSG` is similar to `BOOST_ASSERT`, but it takes an additional argument,
a character literal, supplying an error message.

* By default, `BOOST_ASSERT_MSG(expr,msg)` expands to `assert\((expr)&&(msg))`.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr,msg)` expands to `((void)0)`, regardless of whether
the macro `NDEBUG` is defined.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr,msg)` expands to
+
```
(BOOST_LIKELY(!!(expr))? ((void)0): ::boost::assertion_failed_msg(#expr,
    msg, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
```
+
This is true regardless of whether `NDEBUG` is defined.
+
`boost::assertion_failed_msg` is declared in `<boost/assert.hpp>` as
+
```
namespace boost
{
    void assertion_failed_msg(char const * expr, char const * msg,
        char const * function, char const * file, long line);
}
```
+
but it is never defined. The user is expected to supply an appropriate definition.

* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined when `<boost/assert.hpp>`
is included, `BOOST_ASSERT_MSG(expr)` expands to `((void)0)` when `NDEBUG` is
defined. Otherwise the behavior is as if `BOOST_ENABLE_ASSERT_HANDLER` has been defined.

As is the case with `<cassert>`, `<boost/assert.hpp>`
can be included multiple times in a single translation unit. `BOOST_ASSERT_MSG`
will be redefined each time as specified above.

## BOOST_VERIFY

The macro `BOOST_VERIFY` has the same behavior as `BOOST_ASSERT`, except that 
the expression that is passed to `BOOST_VERIFY` is always 
evaluated. This is useful when the asserted expression has desirable side 
effects; it can also help suppress warnings about unused variables when the 
only use of the variable is inside an assertion.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY(expr)` expands to `\((void)(expr))`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY(expr)` expands to `BOOST_ASSERT(expr)`.

* Otherwise, `BOOST_VERIFY(expr)` expands to `\((void)(expr))` when `NDEBUG` is
  defined, to `BOOST_ASSERT(expr)` when it's not.

## BOOST_VERIFY_MSG

The macro `BOOST_VERIFY_MSG` is similar to `BOOST_VERIFY`, with an additional parameter, an error message.

* If the macro `BOOST_DISABLE_ASSERTS` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY_MSG(expr,msg)` expands to `\((void)(expr))`.

* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined when `<boost/assert.hpp>`
  is included, `BOOST_VERIFY_MSG(expr,msg)` expands to `BOOST_ASSERT_MSG(expr,msg)`.

* Otherwise, `BOOST_VERIFY_MSG(expr,msg)` expands to `\((void)(expr))` when `NDEBUG` is
  defined, to `BOOST_ASSERT_MSG(expr,msg)` when it's not.

## BOOST_ASSERT_IS_VOID

The macro `BOOST_ASSERT_IS_VOID` is defined when `BOOST_ASSERT` and `BOOST_ASSERT_MSG` are expanded to `((void)0)`.
Its purpose is to avoid compiling and potentially running code that is only intended to prepare data to be used in the assertion.

```
void MyContainer::erase(iterator i)
{
// Some sanity checks, data must be ordered
#ifndef BOOST_ASSERT_IS_VOID

    if(i != c.begin()) {
        iterator prev = i;
        --prev;
        BOOST_ASSERT(*prev < *i);
    }
    else if(i != c.end()) {
        iterator next = i;
        ++next;
        BOOST_ASSERT(*i < *next);
    }

#endif

    this->erase_impl(i);
}
```      

* By default, `BOOST_ASSERT_IS_VOID` is defined if `NDEBUG` is defined.
* If the macro `BOOST_DISABLE_ASSERTS` is defined, `BOOST_ASSERT_IS_VOID` is always defined.
* If the macro `BOOST_ENABLE_ASSERT_HANDLER` is defined, `BOOST_ASSERT_IS_VOID` is never defined.
* If the macro `BOOST_ENABLE_ASSERT_DEBUG_HANDLER` is defined, then `BOOST_ASSERT_IS_VOID` is defined when `NDEBUG` is defined.
